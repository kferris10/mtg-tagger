<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Tagger</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 2rem;
        }
        .dashboard {
            display: grid;
            grid-template-columns: minmax(360px, 38%) 1fr;
            gap: 2.5rem;
            max-width: 1600px;
            margin: 0 auto;
        }
        .left-panel {
            position: sticky;
            top: 2rem;
            align-self: flex-start;
        }
        .right-panel {
            position: relative;
            min-height: 300px;
        }
        .right-panel.loading {
            opacity: 0.5;
            pointer-events: none;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 0.25rem;
            color: #c9a959;
        }
        .subtitle {
            color: #888;
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.4rem;
            font-size: 0.9rem;
        }
        input, textarea {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 1px solid #333;
            border-radius: 6px;
            background: #16213e;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.95rem;
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #c9a959;
        }
        textarea { resize: vertical; min-height: 160px; }
        #mechanics { min-height: 200px; font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 0.85rem; }
        .field { margin-bottom: 1.2rem; }
        button {
            background: #c9a959;
            color: #1a1a2e;
            border: none;
            padding: 0.7rem 1.6rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
        }
        button:hover { background: #d4b96a; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .optional-label {
            color: #888;
            font-size: 0.8rem;
            font-weight: 400;
            font-style: italic;
        }

        /* Loading bar */
        .loading-bar {
            height: 3px;
            background: #333;
            border-radius: 2px;
            margin-top: 0.75rem;
            overflow: hidden;
            visibility: hidden;
        }
        .loading-bar.visible { visibility: visible; }
        .loading-bar::after {
            content: "";
            display: block;
            width: 30%;
            height: 100%;
            background: #c9a959;
            border-radius: 2px;
            animation: loading-slide 1.2s ease-in-out infinite;
        }
        @keyframes loading-slide {
            0%   { transform: translateX(-100%); }
            100% { transform: translateX(433%); }
        }

        /* Error toast */
        .error-toast {
            position: fixed;
            top: 2rem;
            right: 2rem;
            max-width: 400px;
            padding: 0.8rem 2.5rem 0.8rem 1rem;
            background: #3a1a1a;
            border: 1px solid #a33;
            border-radius: 6px;
            color: #f88;
            font-size: 0.9rem;
            z-index: 100;
            transform: translateX(calc(100% + 2rem));
            transition: transform 0.3s ease;
        }
        .error-toast.visible {
            animation: toast-slide-in 0.3s ease forwards;
        }
        @keyframes toast-slide-in {
            from { transform: translateX(calc(100% + 2rem)); }
            to   { transform: translateX(0); }
        }
        .error-dismiss {
            position: absolute;
            top: 0.5rem;
            right: 0.6rem;
            background: none;
            border: none;
            color: #f88;
            font-size: 1rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            font-weight: 400;
        }
        .error-dismiss:hover { color: #faa; background: none; }

        /* Empty state */
        .empty-state {
            color: #555;
            font-style: italic;
            text-align: center;
            padding-top: 6rem;
            font-size: 1rem;
        }
        .empty-state.hidden { display: none; }

        .results {
            display: none;
        }
        .results.visible { display: block; }
        .results h2 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #c9a959;
        }
        pre {
            background: #16213e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 1rem;
            overflow-x: auto;
            white-space: pre-wrap;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
        }
        .results-table th,
        .results-table td {
            text-align: left;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #333;
        }
        .results-table th {
            color: #c9a959;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .results-table td { font-size: 0.95rem; }
        .sort-header {
            cursor: pointer;
            user-select: none;
        }
        .sort-header:hover { color: #d4b96a; }
        .sort-arrow {
            font-size: 0.75rem;
            margin-left: 0.3rem;
        }
        .badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 0.4rem;
            margin-bottom: 0.3rem;
        }
        .badge-s  { background: #a08520; color: #fff; }
        .badge-a  { background: #2e7d32; color: #fff; }
        .badge-b  { background: #1565c0; color: #fff; }
        .badge-c  { background: #555;    color: #ccc; }
        .badge-d  { background: #8b1a1a; color: #fff; }
        .category-counts {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            position: sticky;
            top: 0;
            background: #1a1a2e;
            padding: 0.5rem 0;
            z-index: 10;
            border-bottom: 1px solid #333;
        }
        .count-chip {
            background: #16213e;
            border: 1px solid #333;
            border-radius: 999px;
            padding: 0.3rem 0.8rem;
            font-size: 0.85rem;
            color: #c9a959;
        }
        .muted { color: #666; font-style: italic; font-size: 0.9rem; }

        /* Filter controls */
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            gap: 1rem;
        }
        .card-search {
            max-width: 250px;
            padding: 0.5rem 0.7rem;
            border: 1px solid #333;
            border-radius: 6px;
            background: #16213e;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        .card-search:focus {
            outline: none;
            border-color: #c9a959;
        }
        .clear-filters-btn {
            background: transparent;
            color: #c9a959;
            border: 1px solid #c9a959;
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .clear-filters-btn:hover {
            background: #c9a959;
            color: #1a1a2e;
        }

        /* Clickable chips */
        .count-chip {
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .count-chip:hover {
            background: #1e2a4a;
            border-color: #c9a959;
        }
        .count-chip.active {
            background: #2a3552;
            border: 2px solid #c9a959;
            font-weight: 700;
        }

        /* Tier filters */
        .tier-filters {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #333;
        }
        .tier-label {
            color: #888;
            font-size: 0.85rem;
            margin-right: 0.25rem;
        }
        .tier-filter {
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.15s ease;
        }
        .tier-filter:hover {
            opacity: 0.75;
        }
        .tier-filter.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(201, 169, 89, 0.4);
        }

        /* Filter info */
        .filter-info {
            color: #888;
            font-size: 0.9rem;
            margin-top: 0.75rem;
            font-style: italic;
        }
        .empty-filter-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #888;
        }
        .empty-filter-state button {
            margin-top: 1rem;
        }

        /* Card detail panel */
        .card-detail { margin-top: 1.5rem; display: none; }
        .card-detail.visible { display: block; }
        #card-select {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 1px solid #333;
            border-radius: 6px;
            background: #16213e;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
        }
        #card-select:focus { outline: none; border-color: #c9a959; }
        .card-rating-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0;
            border-bottom: 1px solid #2a2a3e;
        }
        .card-no-mechanics { color: #666; font-style: italic; font-size: 0.9rem; padding: 0.4rem 0; }
        .raw-toggle {
            background: none;
            border: none;
            color: #c9a959;
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0;
            font-weight: 600;
            margin-top: 1rem;
            display: inline-block;
        }
        .raw-toggle:hover { text-decoration: underline; background: none; }
        .raw-json { display: none; margin-top: 0.5rem; }
        .raw-json.visible { display: block; }

        /* View toggle tabs */
        .view-toggle-bar { display: flex; border-bottom: 2px solid #333; margin-bottom: 1rem; }
        .view-tab { background: transparent; color: #888; border: none;
                    border-bottom: 2px solid transparent; margin-bottom: -2px;
                    padding: 0.45rem 1.1rem; font-size: 0.9rem; font-weight: 600; cursor: pointer; }
        .view-tab:hover { color: #c9a959; background: transparent; }
        .view-tab.active { color: #c9a959; border-bottom-color: #c9a959; }

        /* Tier list rows */
        .tierlist { display: flex; flex-direction: column; gap: 0.5rem; }
        .tier-row { display: flex; align-items: stretch; min-height: 110px;
                    border: 1px solid #333; border-radius: 6px; overflow: hidden; }
        .tier-row-label { width: 54px; min-width: 54px; display: flex; align-items: center;
                          justify-content: center; font-size: 1.1rem; font-weight: 800;
                          color: #fff; flex-shrink: 0; border-radius: 0; }
        .tier-row-label.badge-s, .tier-row-label.badge-a, .tier-row-label.badge-b,
        .tier-row-label.badge-c, .tier-row-label.badge-d { border-radius: 0; padding: 0; }
        .tier-row-tiles { display: flex; flex-wrap: wrap; gap: 0.5rem;
                          padding: 0.5rem; background: #16213e; flex: 1;
                          align-content: flex-start; }

        /* Card tiles */
        .card-tile { display: flex; flex-direction: column; align-items: center;
                     width: 90px; text-align: center; }
        .card-tile-art { width: 90px; height: 65px; border-radius: 4px; overflow: hidden;
                         background: #0d1526; display: flex; align-items: center;
                         justify-content: center; }
        .card-tile-img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .card-tile-placeholder { width: 100%; height: 100%; background: #2a2a3e; }
        .card-tile-name { font-size: 0.68rem; color: #c9a959; margin-top: 0.25rem;
                          line-height: 1.2; max-width: 90px; overflow: hidden;
                          display: -webkit-box; -webkit-line-clamp: 2;
                          -webkit-box-orient: vertical; word-break: break-word; }
        .card-tile-mechanic { font-size: 0.6rem; color: #888; margin-top: 0.1rem;
                              max-width: 90px; white-space: nowrap; text-overflow: ellipsis;
                              overflow: hidden; }
        .tile-spinner { width: 20px; height: 20px; border: 2px solid #333;
                        border-top-color: #c9a959; border-radius: 50%;
                        animation: tile-spin 0.7s linear infinite; }
        @keyframes tile-spin { to { transform: rotate(360deg); } }

        @media (max-width: 768px) {
            .dashboard { grid-template-columns: 1fr; gap: 1.5rem; }
            .left-panel { position: static; }
            .category-counts { position: static; }
            .error-toast { left: 1rem; right: 1rem; max-width: none; }
            .filter-header {
                flex-direction: column;
                align-items: stretch;
            }
            .card-search {
                max-width: none;
                width: 100%;
            }
            .tier-filters {
                flex-wrap: wrap;
            }
            .tier-row-label { width: 40px; min-width: 40px; font-size: 0.9rem; }
            .card-tile { width: 74px; }
            .card-tile-art { width: 74px; height: 54px; }
            .card-tile-name, .card-tile-mechanic { max-width: 74px; }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="left-panel">
            <h1>MTG Tagger</h1>
            <p class="subtitle">Analyze Magic: The Gathering cards for Commander mechanics and tier ratings</p>

            <div class="field">
                <label for="access-code">Access Code</label>
                <input type="password" id="access-code" placeholder="Enter access code">
            </div>

            <div class="field">
                <label for="mechanics">
                    Mechanics to Tag
                    <span class="optional-label">(edit or add your own)</span>
                </label>
                <textarea id="mechanics" placeholder="- mechanic_name: Description..."></textarea>
            </div>

            <div class="field">
                <label for="card-data">Card Data</label>
                <textarea id="card-data"></textarea>
            </div>

            <button id="submit-btn">Analyze Cards</button>
            <div class="loading-bar" id="loading"></div>

            <div class="card-detail" id="card-detail">
                <label for="card-select">Card Details</label>
                <select id="card-select">
                    <option value="">Select a card...</option>
                </select>
                <div id="card-ratings"></div>
            </div>
        </div>

        <div class="right-panel" id="right-panel">
            <div class="empty-state" id="empty-state">Submit cards to see results</div>
            <div class="error-toast" id="error">
                <button class="error-dismiss" id="error-dismiss">&times;</button>
                <span id="error-msg"></span>
            </div>
            <div class="results" id="results">
                <h2>Results</h2>
                <div id="results-filters"></div>
                <div class="view-toggle-bar">
                    <button class="view-tab" id="tab-table" data-view="table">Table</button>
                    <button class="view-tab active" id="tab-tierlist" data-view="tierlist">Tier List</button>
                </div>
                <div id="results-table" style="display:none;"></div>
                <div id="results-tierlist"></div>
                <button class="raw-toggle" id="raw-toggle">Show raw JSON</button>
                <div class="raw-json" id="raw-json">
                    <pre id="results-content"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        const btn = document.getElementById("submit-btn");
        const loading = document.getElementById("loading");
        const errorEl = document.getElementById("error");
        const errorMsg = document.getElementById("error-msg");
        const errorDismiss = document.getElementById("error-dismiss");
        const resultsEl = document.getElementById("results");
        const resultsContent = document.getElementById("results-content");
        const resultsTable = document.getElementById("results-table");
        const rawToggle = document.getElementById("raw-toggle");
        const rawJson = document.getElementById("raw-json");
        const rightPanel = document.getElementById("right-panel");
        const emptyState = document.getElementById("empty-state");

        const cardDetail = document.getElementById("card-detail");
        const cardSelect = document.getElementById("card-select");
        const cardRatings = document.getElementById("card-ratings");

        let errorTimer = null;
        let lastResult = null;

        // View state
        let currentView = "tierlist";
        let lastRows = [];
        let noMechCountGlobal = 0;
        let renderTableFn = null;
        let renderFiltersFn = null;
        const scryfallCache = {};
        const scryfallQueue = [];
        let scryfallRunning = false;

        // Filter state
        const filterState = {
            mechanics: new Set(),
            tiers: new Set(),
            searchText: ""
        };

        function hasActiveFilters() {
            return filterState.mechanics.size > 0 ||
                   filterState.tiers.size > 0 ||
                   filterState.searchText.trim() !== "";
        }

        function applyFilters(rows) {
            if (!hasActiveFilters()) {
                return rows;
            }

            return rows.filter(row => {
                // Mechanic filter (OR logic within mechanics)
                const mechMatch = filterState.mechanics.size === 0 ||
                                 filterState.mechanics.has(row.mechanic);

                // Tier filter (OR logic within tiers)
                const tierMatch = filterState.tiers.size === 0 ||
                                 filterState.tiers.has(row.tierRankVal);

                // Search filter (AND logic for card name)
                const searchMatch = filterState.searchText === "" ||
                                   row.card.toLowerCase().includes(
                                       filterState.searchText.toLowerCase()
                                   );

                // Combine with AND logic between filter types
                return mechMatch && tierMatch && searchMatch;
            });
        }

        function clearAllFilters() {
            filterState.mechanics.clear();
            filterState.tiers.clear();
            filterState.searchText = "";
            const searchInput = document.getElementById("card-search");
            if (searchInput) searchInput.value = "";
        }

        function switchView(view) {
            currentView = view;
            document.getElementById("tab-table").classList.toggle("active", view === "table");
            document.getElementById("tab-tierlist").classList.toggle("active", view === "tierlist");
            document.getElementById("results-table").style.display = view === "table" ? "" : "none";
            document.getElementById("results-tierlist").style.display = view === "tierlist" ? "" : "none";
            renderActiveView();
        }

        function renderActiveView() {
            if (currentView === "table" && renderTableFn) renderTableFn();
            else if (currentView === "tierlist" && lastRows.length > 0) renderTierList();
        }

        // Generate display label from mechanic key
        function formatMechanicLabel(mechKey) {
            // Use predefined label if exists, otherwise format the key
            const PREDEFINED_LABELS = {
                ramp: "Ramp",
                card_advantage: "Card Advantage",
                targeted_disruption: "Targeted Disruption",
                mass_disruption: "Mass Disruption",
                go_wide: "Go Wide",
                anthem: "Anthem",
                overrun: "Overrun"
            };

            if (PREDEFINED_LABELS[mechKey]) {
                return PREDEFINED_LABELS[mechKey];
            }

            // Fallback: convert snake_case to Title Case
            return mechKey
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function renderCardDetail(cardName) {
            const mechanics = lastResult[cardName];
            if (!mechanics) { cardRatings.innerHTML = ""; return; }
            const entries = Object.entries(mechanics);
            if (entries.length === 0) {
                cardRatings.innerHTML = '<p class="card-no-mechanics">No tagged mechanics</p>';
                return;
            }
            let html = "";
            for (const [mech, tier] of entries) {
                const label = formatMechanicLabel(mech);
                const cls = tierBadgeClass(tier);
                html += `<div class="card-rating-row"><span>${esc(label)}</span><span class="badge ${cls}">${esc(tier)}</span></div>`;
            }
            cardRatings.innerHTML = html;
        }

        cardSelect.addEventListener("change", () => {
            if (cardSelect.value) renderCardDetail(cardSelect.value);
            else cardRatings.innerHTML = "";
        });

        rawToggle.addEventListener("click", () => {
            rawJson.classList.toggle("visible");
            rawToggle.textContent = rawJson.classList.contains("visible")
                ? "Hide raw JSON" : "Show raw JSON";
        });

        function dismissError() {
            errorEl.classList.remove("visible");
            if (errorTimer) { clearTimeout(errorTimer); errorTimer = null; }
        }

        errorDismiss.addEventListener("click", dismissError);
        errorEl.addEventListener("click", dismissError);

        function esc(str) {
            const d = document.createElement("div");
            d.textContent = str;
            return d.innerHTML;
        }

        function tierBadgeClass(tier) {
            const t = tier.toLowerCase();
            if (t.startsWith("s"))  return "badge-s";
            if (t.startsWith("a"))  return "badge-a";
            if (t.startsWith("b"))  return "badge-b";
            if (t.startsWith("c"))  return "badge-c";
            if (t.startsWith("d"))  return "badge-d";
            return "badge-c";
        }

        function tierRank(tier) {
            const t = tier.toLowerCase().replace(/[- ]?tier$/i, "").trim();
            const ranks = {"s+": 0, "s": 1, "a": 2, "b": 3, "c": 4, "d": 5};
            return ranks[t] !== undefined ? ranks[t] : 6;
        }

        function renderResults(data) {
            // Reset filters when new data arrives
            clearAllFilters();

            // If the API returned a plain string, show it as raw text
            if (typeof data === "string") {
                try {
                    data = JSON.parse(data);
                } catch {
                    resultsTable.innerHTML = `<pre>${data}</pre>`;
                    resultsContent.textContent = data;
                    rawJson.classList.remove("visible");
                    rawToggle.textContent = "Show raw JSON";
                    return;
                }
            }
            const result = data;

            // Build flat rows array
            const rows = [];
            let noMechCount = 0;
            for (const [cardName, mechanics] of Object.entries(result)) {
                const mechEntries = Object.entries(mechanics);
                if (mechEntries.length === 0) {
                    noMechCount++;
                } else {
                    for (const [mech, tier] of mechEntries) {
                        rows.push({
                            card: cardName,
                            mechanic: mech,
                            mechanicLabel: formatMechanicLabel(mech),
                            tier: tier,
                            tierRankVal: tierRank(tier)
                        });
                    }
                }
            }
            lastRows = rows;
            noMechCountGlobal = noMechCount;

            // Category counts with mechanic key mapping
            const counts = {};
            const mechanicKeyMap = {}; // Map label → key
            for (const row of rows) {
                counts[row.mechanicLabel] = (counts[row.mechanicLabel] || 0) + 1;
                mechanicKeyMap[row.mechanicLabel] = row.mechanic;
            }
            const countsSorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            // Sort state
            let sortCol = "tier";
            let sortAsc = true; // ascending tierRank = strongest first

            function renderFilters() {
                const filtersEl = document.getElementById("results-filters");
                const filteredRows = applyFilters(rows);

                // Filter header with search and clear button
                let html = '<div class="filter-header">';
                html += '<input type="text" id="card-search" class="card-search" placeholder="Search cards...">';
                html += `<button id="clear-filters" class="clear-filters-btn" style="display: ${hasActiveFilters() ? 'inline-block' : 'none'}">Clear filters</button>`;
                html += '</div>';

                // Category counts
                html += '<div class="category-counts">';
                for (const [label, count] of countsSorted) {
                    const mechKey = mechanicKeyMap[label];
                    const isActive = filterState.mechanics.has(mechKey);
                    html += `<span class="count-chip${isActive ? ' active' : ''}" data-mechanic="${esc(mechKey)}">${esc(label)}: ${count}</span>`;
                }

                // Tier filters
                html += '<div class="tier-filters"><span class="tier-label">Tiers:</span>';
                const tiers = [
                    {rank: 0, label: 'S+', class: 'badge-s'},
                    {rank: 1, label: 'S',  class: 'badge-s'},
                    {rank: 2, label: 'A',  class: 'badge-a'},
                    {rank: 3, label: 'B',  class: 'badge-b'},
                    {rank: 4, label: 'C',  class: 'badge-c'},
                    {rank: 5, label: 'D',  class: 'badge-d'}
                ];
                for (const tier of tiers) {
                    const isActive = filterState.tiers.has(tier.rank);
                    html += `<span class="badge tier-filter ${tier.class}${isActive ? ' active' : ''}" data-tier="${tier.rank}">${tier.label}</span>`;
                }
                html += '</div></div>'; // tier-filters, category-counts

                if (hasActiveFilters() && filteredRows.length < rows.length) {
                    html += `<p class="filter-info">Showing ${filteredRows.length} of ${rows.length} results</p>`;
                }

                filtersEl.innerHTML = html;
                attachFilterHandlers();
            }

            function renderTable() {
                const filteredRows = applyFilters(rows);
                filteredRows.sort((a, b) => {
                    let cmp = 0;
                    if (sortCol === "card") {
                        cmp = a.card.localeCompare(b.card);
                    } else if (sortCol === "mechanic") {
                        cmp = a.mechanicLabel.localeCompare(b.mechanicLabel);
                    } else {
                        cmp = a.tierRankVal - b.tierRankVal;
                    }
                    return sortAsc ? cmp : -cmp;
                });

                const arrow = sortAsc ? "▲" : "▼";
                const thCard = `Card${sortCol === "card" ? ' <span class="sort-arrow">' + arrow + '</span>' : ''}`;
                const thMech = `Mechanic${sortCol === "mechanic" ? ' <span class="sort-arrow">' + arrow + '</span>' : ''}`;
                const thTier = `Tier${sortCol === "tier" ? ' <span class="sort-arrow">' + arrow + '</span>' : ''}`;

                if (filteredRows.length === 0 && hasActiveFilters()) {
                    resultsTable.innerHTML = '<div class="empty-filter-state"><p>No cards match your filters</p><button id="clear-filters-empty">Clear all filters</button></div>';
                    const clearEmptyBtn = document.getElementById("clear-filters-empty");
                    if (clearEmptyBtn) {
                        clearEmptyBtn.addEventListener("click", () => {
                            clearAllFilters();
                            renderFilters();
                            renderActiveView();
                        });
                    }
                    return;
                }

                let html = '<table class="results-table"><thead><tr>';
                html += `<th class="sort-header" data-col="card">${thCard}</th>`;
                html += `<th class="sort-header" data-col="mechanic">${thMech}</th>`;
                html += `<th class="sort-header" data-col="tier">${thTier}</th>`;
                html += '</tr></thead><tbody>';
                for (const row of filteredRows) {
                    const cls = tierBadgeClass(row.tier);
                    html += `<tr><td>${esc(row.card)}</td><td>${esc(row.mechanicLabel)}</td><td><span class="badge ${cls}">${esc(row.tier)}</span></td></tr>`;
                }
                html += '</tbody></table>';
                if (noMechCount > 0) {
                    html += `<p class="muted">${noMechCount} card${noMechCount === 1 ? '' : 's'} had no tagged mechanics</p>`;
                }

                resultsTable.innerHTML = html;
                resultsTable.querySelectorAll(".sort-header").forEach(th => {
                    th.addEventListener("click", () => {
                        const col = th.getAttribute("data-col");
                        if (sortCol === col) { sortAsc = !sortAsc; } else { sortCol = col; sortAsc = true; }
                        renderTable();
                    });
                });
            }

            renderTableFn = renderTable;
            renderFiltersFn = renderFilters;

            function attachFilterHandlers() {
                const searchInput = document.getElementById("card-search");
                if (searchInput) {
                    searchInput.value = filterState.searchText;
                    searchInput.addEventListener("input", (e) => {
                        filterState.searchText = e.target.value.trim();
                        renderFilters();
                        renderActiveView();
                    });
                }

                const clearBtn = document.getElementById("clear-filters");
                if (clearBtn) {
                    clearBtn.addEventListener("click", () => {
                        clearAllFilters();
                        renderFilters();
                        renderActiveView();
                    });
                }

                document.querySelectorAll(".count-chip").forEach(chip => {
                    chip.addEventListener("click", () => {
                        const mechanic = chip.getAttribute("data-mechanic");
                        if (filterState.mechanics.has(mechanic)) { filterState.mechanics.delete(mechanic); }
                        else { filterState.mechanics.add(mechanic); }
                        renderFilters();
                        renderActiveView();
                    });
                });

                document.querySelectorAll(".tier-filter").forEach(badge => {
                    badge.addEventListener("click", () => {
                        const tier = parseInt(badge.getAttribute("data-tier"));
                        if (filterState.tiers.has(tier)) { filterState.tiers.delete(tier); }
                        else { filterState.tiers.add(tier); }
                        renderFilters();
                        renderActiveView();
                    });
                });
            }

            renderFilters();
            switchView("tierlist");

            // Raw JSON
            resultsContent.textContent = JSON.stringify(result, null, 2);
            rawJson.classList.remove("visible");
            rawToggle.textContent = "Show raw JSON";

            // Card detail panel
            lastResult = result;
            const cardNames = Object.keys(result);
            cardSelect.innerHTML = '<option value="">Select a card...</option>';
            for (const name of cardNames) {
                cardSelect.innerHTML += `<option value="${esc(name)}">${esc(name)}</option>`;
            }
            if (cardNames.length > 0) {
                cardSelect.value = cardNames[0];
                renderCardDetail(cardNames[0]);
            }
            cardDetail.classList.add("visible");
        }

        // Scryfall art fetch with rate-limited queue
        async function fetchArtCrop(cardName) {
            const key = cardName.toLowerCase();
            if (key in scryfallCache) return scryfallCache[key];
            return new Promise((resolve) => {
                scryfallQueue.push({ cardName, key, resolve });
                if (!scryfallRunning) runScryfallQueue();
            });
        }

        async function runScryfallQueue() {
            scryfallRunning = true;
            while (scryfallQueue.length > 0) {
                const { cardName, key, resolve } = scryfallQueue.shift();
                if (key in scryfallCache) { resolve(scryfallCache[key]); continue; }
                try {
                    const res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
                    const artUrl = res.ok ? (await res.json()).image_uris?.art_crop ?? null : null;
                    scryfallCache[key] = artUrl;
                    resolve(artUrl);
                } catch {
                    scryfallCache[key] = null;
                    resolve(null);
                }
                await new Promise(r => setTimeout(r, 100));
            }
            scryfallRunning = false;
        }

        function renderTierList() {
            const TIER_DEFS = [
                { rank: 0, label: "S+", badgeClass: "badge-s" },
                { rank: 1, label: "S",  badgeClass: "badge-s" },
                { rank: 2, label: "A",  badgeClass: "badge-a" },
                { rank: 3, label: "B",  badgeClass: "badge-b" },
                { rank: 4, label: "C",  badgeClass: "badge-c" },
                { rank: 5, label: "D",  badgeClass: "badge-d" },
            ];

            const tierListEl = document.getElementById("results-tierlist");
            const filteredRows = applyFilters(lastRows);

            if (filteredRows.length === 0 && hasActiveFilters()) {
                tierListEl.innerHTML = '<div class="empty-filter-state"><p>No cards match your filters</p></div>';
                return;
            }

            // Group filtered rows by tier rank
            const byTier = {};
            for (const row of filteredRows) {
                if (!byTier[row.tierRankVal]) byTier[row.tierRankVal] = [];
                byTier[row.tierRankVal].push(row);
            }

            let html = '<div class="tierlist">';
            for (const td of TIER_DEFS) {
                const tierRows = byTier[td.rank];
                if (!tierRows || tierRows.length === 0) continue;
                html += `<div class="tier-row">`;
                html += `<div class="tier-row-label ${td.badgeClass}">${esc(td.label)}</div>`;
                html += `<div class="tier-row-tiles">`;
                tierRows.forEach((row, i) => {
                    const escapedName = esc(row.card);
                    html += `<div class="card-tile" id="tile-${td.rank}-${i}">`;
                    html += `<div class="card-tile-art" data-card="${escapedName}">`;
                    html += `<div class="tile-spinner"></div>`;
                    html += `</div>`;
                    html += `<div class="card-tile-name">${escapedName}</div>`;
                    html += `<div class="card-tile-mechanic">${esc(row.mechanicLabel)}</div>`;
                    html += `</div>`;
                });
                html += `</div></div>`;
            }
            if (noMechCountGlobal > 0) {
                html += `<p class="muted" style="margin-top:0.5rem">${noMechCountGlobal} card${noMechCountGlobal === 1 ? '' : 's'} had no tagged mechanics</p>`;
            }
            html += '</div>';
            tierListEl.innerHTML = html;

            // Fetch art crops — unique card names from visible tiles
            const seen = new Set();
            for (const row of filteredRows) {
                if (seen.has(row.card)) continue;
                seen.add(row.card);
                const cardName = row.card;
                fetchArtCrop(cardName).then(artUrl => {
                    const escapedName = esc(cardName);
                    const artEls = tierListEl.querySelectorAll(`[data-card="${escapedName}"]`);
                    artEls.forEach(el => {
                        if (artUrl) {
                            el.innerHTML = `<img class="card-tile-img" src="${artUrl}" alt="${escapedName}" loading="lazy">`;
                        } else {
                            el.innerHTML = `<div class="card-tile-placeholder"></div>`;
                        }
                    });
                });
            }
        }

        btn.addEventListener("click", async () => {
            const cardData = document.getElementById("card-data").value.trim();
            const accessCode = document.getElementById("access-code").value.trim();
            const mechanics = document.getElementById("mechanics").value.trim();

            if (!cardData) {
                showError("Please enter card data.");
                return;
            }

            btn.disabled = true;
            loading.classList.add("visible");
            rightPanel.classList.add("loading");
            dismissError();
            resultsEl.classList.remove("visible");

            const body = {
                card_data: cardData,
                access_code: accessCode || undefined,
                mechanics: mechanics || undefined
            };

            try {
                const res = await fetch("/analyze", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });

                const data = await res.json();

                if (!res.ok) {
                    if (res.status === 403) {
                        localStorage.removeItem("mtg_tagger_access_code");
                        showError(data.error || "Access denied: incorrect access code.");
                        document.getElementById("access-code").focus();
                        return;
                    }
                    showError(data.error || "An unexpected error occurred.");
                    return;
                }

                if (accessCode) {
                    localStorage.setItem("mtg_tagger_access_code", accessCode);
                }

                emptyState.classList.add("hidden");
                renderResults(data.result);
                resultsEl.classList.add("visible");
            } catch (e) {
                if (e instanceof TypeError || e instanceof SyntaxError) {
                    showError("Error rendering results: " + e.message);
                } else {
                    showError("Network error: could not reach the server.");
                }
            } finally {
                btn.disabled = false;
                loading.classList.remove("visible");
                rightPanel.classList.remove("loading");
            }
        });

        function showError(msg) {
            errorMsg.textContent = msg;
            errorEl.classList.add("visible");
            if (errorTimer) clearTimeout(errorTimer);
            errorTimer = setTimeout(() => {
                errorEl.classList.remove("visible");
                errorTimer = null;
            }, 5000);
        }

        // Load default mechanics on page load
        async function loadDefaultMechanics() {
            try {
                const res = await fetch('/api/default-mechanics');
                const data = await res.json();
                document.getElementById('mechanics').value = data.mechanics;
            } catch (e) {
                console.error('Failed to load default mechanics:', e);
                // Fallback: set a basic default in the textarea
                document.getElementById('mechanics').placeholder =
                    '- ramp: Accelerates your mana production...\n' +
                    '- card_advantage: Net positive card advantage...';
            }
        }

        // Default card list
        const DEFAULT_CARDS = `1 Adorned Pouncer
1 Angelic Cub
1 Arahbo, Roar of the World
1 Arahbo, the First Fang
1 Arcane Signet
1 Austere Command
1 Blackblade Reforged
1 Bloodforged Battle-Axe
1 Bronzehide Lion
1 Buried Ruin
1 Canopy Vista
1 Command Tower
1 Conjurer's Mantle
1 Dawn of a New Age
1 Enlightened Ascetic
1 Entish Restoration
1 Evolving Wilds
1 Felidar Cub
1 Felidar Retreat
1 Feline Sovereign
1 Fleecemane Lion
1 Folk Hero
11 Forest
1 Harvest Season
1 Herd Heirloom
1 Horn of the Mark
1 Hunter's Insight
1 Hunter's Prowess
1 Jazal Goldmane
1 Kaheera, the Orphanguard
1 Keen Sense
1 Keeper of Fables
1 King of the Pride
1 Krosan Verge
1 Kutzil, Malamet Exemplar
1 Leonin Relic-Warder
1 Leonin Skyhunter
1 Leonin Vanguard
1 Lion Sash
1 Loam Lion
1 Mirari's Wake
1 Mirri, Weatherlight Duelist
1 Mosswort Bridge
1 Myriad Landscape
1 Nissa's Pilgrimage
1 Patchwork Banner
1 Path of Ancestry
15 Plains
1 Qasali Ambusher
1 Qasali Pridemage
1 Qasali Slingers
1 Rampant Growth
1 Reprieve
1 Rogue's Passage
1 Rout
1 Sacred Cat
1 Savannah Lions
1 Scythe Leopard
1 Selesnya Sanctuary
1 Sixth Sense
1 Sol Ring
1 Soul's Majesty
1 Stalking Leonin
1 Steppe Lynx
1 Stirring Wildwood
1 Storm of Souls
1 Sword of the Animist
1 Sword of Vengeance
1 Terramorphic Expanse
1 Thought Vessel
1 Trained Caracal
1 Traverse the Outlands
1 White Sun's Zenith
1 Whitemane Lion
1 Wild Growth
1 Wily Bandar`;

        document.getElementById("card-data").value = DEFAULT_CARDS;

        // Call on page load
        loadDefaultMechanics();

        const savedCode = localStorage.getItem("mtg_tagger_access_code");
        if (savedCode) {
            document.getElementById("access-code").value = savedCode;
        }

        document.getElementById("tab-table").addEventListener("click", () => switchView("table"));
        document.getElementById("tab-tierlist").addEventListener("click", () => switchView("tierlist"));
    </script>
</body>
</html>
